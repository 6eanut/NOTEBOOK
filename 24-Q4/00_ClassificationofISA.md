# Classification of ISA

> 最近在看[RISC-V v1手册](https://6eanut.github.io/RISCV-READ/RISC-V-Reader-Chinese-v1.pdf)的中文译版，在第一章里面讲到ISA可以分为模块化的和增量化的，还举了很生动的[例子](https://6eanut.github.io/RISCV-READ/01_RISC-V.html)来比喻两者
>
> 后来读胡伟武老师的《计算机体系结构》，里面从**指令对于数据的使用方法**的角度对ISA进行了分类，感觉很有意思

## 0. 从指令对数据的使用方法看ISA

* **堆栈型**(零地址指令)
  * 操作数在栈顶，运算指令不用指定操作数
* **累加器型**(单地址指令)
  * 累加器是隐含操作数，指令中指定另一个操作数，结果写回累加器
* **寄存器型**(每个操作数都由指令显式指定)
  * 寄存器-存储器型
    * 操作数是寄存器或内存地址
  * 寄存器-寄存器型
    * 操作数都是寄存器

只看文字肯定不好理解，不如直接看一个指令例子

## 1. C = A + B

| 堆栈型                                 | 累加器型                       | 寄存器-存储器型                            | 寄存器-寄存器型                                                 |
| :------------------------------------- | :----------------------------- | ------------------------------------------ | :-------------------------------------------------------------- |
| PUSH A<br />PUSH B<br />ADD<br />POP C | LOAD A<br />ADD B<br />STORE C | LOAD R1, A<br />ADD R1, B<br />STORE C, R1 | LOAD R1, A<br />LOAD R2, B<br />ADD R3, R1, R2<br />STORE C, R3 |

### 1.0 堆栈型

~~PUSH和POP都是对堆栈的操作，本应不该有后面的参数；~~PUSH A指的是把A从内存中取出来，然后压入堆栈；如果没有后面的参数A，那么压谁呢？

**解释：**`PUSH A`把A从内存中取出来，压入堆栈；`PUSH B`把B从内存中取出来，压入堆栈；`ADD`把栈顶的两个数弹出，作为加法器的输入，并把输出压回栈；`POP C`把栈顶的数弹出，存入内存单元C中

### 1.1 累加器型

指令的隐含操作数是累加器

**解释：**`LOAD A`把内存单元A存入累加器；`ADD B`把累加器的值与内存单元B的值相加，并把结果写回累加器；`STORE C`把累加器的值存入内存单元C

### 1.2 寄存器-存储器型

一个操作数是寄存器，一个操作数是内存地址

**解释：**`LOAD R1, A`把内存单元A的值存入寄存器R1；`ADD R1, B`把内存单元B的值和寄存器R1的值相加，并把结果写回R1；`STORE C, R1`把寄存器R1的值存入内存单元C

### 1.3 寄存器-寄存器型

两个操作数都是寄存器

**解释：**`LOAD R1, A`把内存单元A的值存入寄存器R1；`LOAD R2, B`把内存单元B的值存入寄存器R2；`ADD R3, R1, R2`把寄存器R1和寄存器R2做加法，把结果写入寄存器R3；`STORE C, R3`把寄存器R3写到内存单元C

## 2. 哪种结构好？

可以从**代码量**和**与内存交换的数据量**两个方面来看

```
// 代码片段
A = B - C
D = A - C
B = D + A
```

|  |  |  |  |  |
| - | - | - | - | - |
|  |  |  |  |  |
|  |  |  |  |  |
